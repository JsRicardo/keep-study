# Vue3 快速 Diff 算法

### 面试题：Vue3 中的 Diff 算法做了哪些改变

> 参考答案：
>
> Vue2 采用双端 diff，而 Vue3 采用了快速 diff + LIS。这两种算法前面的步骤都是相同的，先比较新旧头节点，再比较新旧尾节点。如果头节点和尾节点都相同，说明节点没有变化，直接返回。如果头节点和尾节点不同，说明节点有变化，需要进行更新操作。
>
> 头尾比较完成之后，如果旧节点还有剩余，就将对应的旧 DOM 全部删除，如果新节点列表还有剩余，则将新节点列表中剩余的节点创建对应的 DOM，放置于新头节点对应的 DOM 节点后面
>
> 之后两种算法出现了差异：
>
> `双端diff`会进行旧头新尾比较，无法复用则进行旧尾新头比较，还无法复用则进行暴力对比，这样的处理会存在多余的移动操作，即便一些新节点的前后顺序和旧节点一致，还是会产生移动操作
>
> 而 Vue3 则则会找到新节点在旧节点中对应的索引列表，然后求出最长递增子序列，凡是位于最长递增子序列里面的索引所对应的元素，是不需要移动的，其他的元素则需要移动。这样就做到了只移动需要移动的子节点，最小化 DOM 操作次数。

### 面试题：为什么需要在 diff 算法下这么多功夫，计算也是需要时间的

> 参考答案：
>
> 因为真实节点的创建和销毁是比较耗时的操作，而复用之前的节点只进行移动和修改属性等操作相对性能消耗低一些
>
> 从浏览器渲染原理来解释：
>
> 1. 新建节点涉及内存分配和对象创建：每次新建 DOM 节点，浏览器都需要分配新的内存、创建新的对象，并将其插入到 DOM 树中。
> 2. 布局和样式计算：新建节点后，浏览器需要重新计算布局（reflow）和样式（repaint），这会触发更多的渲染流程。
> 3. 垃圾回收压力：频繁新建和销毁节点会增加垃圾回收的压力，影响性能。
> 4. 移动节点只改变节点的位置：移动节点只是调整 DOM 树中的引用关系，不需要重新分配内存，也不会触发完整的渲染流程，性能消耗更低。
