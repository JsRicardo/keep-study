# 浏览器安全相关

# 一、XSS攻击

XSS攻击（cross site scripting），跨站脚本。xss指的是利用浏览器执行恶意脚本（无论有无跨域），从而进行恶意操作的行为。

攻击目标一般多为：

- 窃取网站cookie
- 监听用户行为，比如监听用户输入账号密码
- 修改DOM，比如伪造登陆表单，发送账号密码
- 在页面中生成广告等

xss攻击一般分`存储型、反射型、文档型`

## 存储型

存储型xss攻击是将攻击的脚本存储至数据库中，又将该脚本发送至客户端，达到攻击目的。

以前微博的评论貌似就中招过（小声哔哔），攻击者通过在评论中输入脚本，并上传至服务器的数据库中，当另外的客户端加载了这条评论时就会执行这段脚本，从而达到攻击的目的。现在前后端一般都会做转义工作了（将特殊符号，脚本里面的符号进行转义），一般来说这一种攻击不太容易中招了。

## 反射型

反射型攻击是通过一个url向服务器发送请求。服务器得到这个请求后，响应请求，将这段信息直接当做HTML返回给浏览器，但是这段信息是一个脚本，所以浏览器直接执行了。
比如
```http
http://baidu.com?kw=<script>document.write('你被我劫持了')</script>
```
之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。

## 文档型

文档型的xss攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！

这样的劫持方式包括`WIFI路由器劫持`或者`本地恶意软件`等。


## 如何防范

明白了这些攻击的原理，其实还是很好防范的。这些攻击方式都是让脚本在浏览器中执行，那我们要做的就是不让恶意脚本在浏览器中执行即可。

1. 转义输入

用户的输入是不应该被信任的，你无法控制用户的输入。所以，不管用户输入了什么，前后端都应该进行转义

2. CSP

CSP，即浏览器中的内容安全策略，它的核心思想就是`服务器决定浏览器`加载哪些资源，具体来说可以完成以下功能:

    1. 限制其他域下的资源加载。
    2. 禁止向其它域提交数据。
    3. 提供上报机制，能帮助我们及时发现 XSS 攻击。

3. HyypOnly

很多XSS攻击的主要对象都是cookie，因为用户的登陆信息一般存储在cookie中，设置了HttpOnly之后，脚本是无法操作cookie的，只有http请求可以操作。

# 二、CSRF攻击

CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。

假如说，你现在登录了微博，然后浏览到一张性感美女的照片，你没有忍住，点了进去。那么恭喜你，你中招了。

为什么中招了？因为这时候你已经登录了，该域名下存储了你的登陆cookie，黑客就可以通过cookie，伪造自己是你

## 图片自动发送GET请求

利用图片的src属性，自动发送get请求，而这个请求会携带上你的cookie，注意，这是一个http请求！
```html
<img src='http://weibo.com?userinfo=info&usersex=sex'>
```
## 表单自动发送请求

黑客可以自动填写，设置自动提交表单，从而在这个提交表单的请求中携带你的登陆信息，让服务器认为是你自己在操作。

## 诱导链接点击

```html
<a href='http://weibo.com?userinfo=info&usersex=sex'>点击查看36D小姐姐</a>
```

和XSS攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作。

## 如何防范

1. Samesite

CSRF攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此我们处理好cookie是可以避免csrf攻击的。

恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是SameSite。

SameSite可以设置为三个值，Strict、Lax和None。

    1. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求weibo.com网站只能在weibo.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
    2. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
    3. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。

2. 验证来源

这就需要要用到请求头中的两个字段: `Origin和Referer`。

其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。

当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。

3. CSRF Token

浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。

然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就会被服务器给拒绝。


# 三、HTTPS为什么让请求更安全

https它其实并不是一个新的协议，而是http协议的增强版。

http在请求的时候是明文传输的，因此，他可能在任何阶段被攻击。经过tcp层、wifi路由、运营商、目标服务器，这些环节都有可能被攻击者拿到数据，进行攻击。这就是`中间人攻击`

这个时候就有了https，他在建立tcp链接的时候，还会建立一个tls链接，使得http和tcp/ip通信的时候并不会直接通信，而是会经过中间层加密 解密。

## 对称加密&非对称加密

1. 对称加密：简单的，加密和解密只有一把秘钥

加密过程

    1. 浏览器给服务器发送一个随机的加密字符 client_random, 和加密方法的列表
    2. 服务器收到这个随机的加密字符，返回一个 server_random 随机的加密字符，和一个选中的加密方法
    3. 现在服务器和客户端同时拥有 三个变量 client_random  server_random  和一个加密方法
    4. 用这个加密方法将两个字符混合起来生成密钥，这个秘钥就是前后端通信的 暗号 了

解密过程

对称解密中的 client_random  server_random 加密方法都是可能被截获到的，而这个加密方法又可以解密，所以中间人攻击可以比较轻易的攻击这种加密方式

2. 非对称加密： 如果有两把秘钥，用A加密，只能用B解密；用B加密，只能用A解密

在这种加密方式中，服务器手里有两把钥匙，一把是`公钥`，也就是说每个人都能拿到，是公开的，另一把是`私钥`，这把私钥只有服务器自己知道。

加密过程

    1. 浏览器给服务器发送一个随机的加密字符 client_random, 和加密方法的列表
    2. 服务器收到这个随机加密字符， 返回一个 server_random 随机的加密字符，和一个选中的加密方法， 还有一个公钥
    3. 现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。

解密过程

非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性

但是，私钥加密的数据同样，用公钥解密，服务器的数据只能用私钥加密发送，这时候中间人攻击获取到了公钥，他可以对服务器的数据进行解密，同样不是很安全。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的

## 两者结合的加密

可以看到，前面分析之后，使用单独的加密方式都会存在安全风险。所以这里将两种加密方式结合起来

加密过程

    1. 浏览器给服务器发送一个随机的加密字符 client_random, 和加密方法的列表
    2. 服务器收到这个随机加密字符， 返回一个 server_random 随机的加密字符，和一个选中的加密方法， 还有一个公钥
    3. 浏览器生成另一个随机字符 pre_random，用收到的公钥加密，传输给服务器
    4. 服务器收到这个pre_random，用私钥解密
    5，现在他们拥有 client_random server_random pre_random 还有加密方法。然后用这个加密方法，混合三个随机字符，生成最终的 暗号

然后服务器和浏览器之间用这个最终的秘钥进行通信，这就是融合两个加密方式的最终加密方式。

这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人攻击没有私钥，从而拿不到pre_random，也就无法生成最终的密钥了。

回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。

## 添加数字证书

尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。

黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。

事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。

为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫`CA(Certificate Authority)`, 认证通过后 CA 会给服务器颁发`数字证书`。

这个数字证书有两个作用:

1. 服务器向浏览器证明自己的身份。
2. 把公钥传给浏览器。

这个验证的过程发生在什么时候呢？

当服务器传送server_random、加密方法的时候，顺便会带上`数字证书(包含了公钥)`, 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。

HTTPS最终的加解密过程，如图：

![image](https://user-gold-cdn.xitu.io/2019/12/15/16f080a6f6375dc1?imageslim)

## 数字证书认证过程
浏览器拿到数字证书后，如何来对证书进行认证呢？

首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个`Hash 函数`，来这个函数来计算明文内容得到信息A，然后用公钥解密明文内容得到信息B，两份信息做`比对`，一致则表示认证合法。

当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。