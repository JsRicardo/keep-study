# js单线程

js的事件分两种，宏任务(macro-task)和微任务(micro-task)，大部分的任务都是在主线程上执行，常见的任务有:

    1. 渲染事件
    2. 用户交互事件
    3. js脚本执行
    4. 网络请求、文件读写完成等事件

在js引擎执行这些事件时，需要依据一定的顺序去执行，V8引擎 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。

事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，`同步的进入主线程`，`异步的进入Event Table`并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。

### 宏任务

包括整体代码script，setTimeout，setInterval

宏任务在js主线程中运行，先进入先执行。而延迟任务setTimeout和setInterval执行之后会返回一个微任务，进入微任务队列，等宏任务队列执行完了之后，再去微任务队列执行微任务

### 微任务

常见的微任务有MutationObserver、Promise.then(或reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程

V8引擎是将微任务放到当前宏任务的末尾。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务

- `微任务有优先执行权`

setTimeout等宏任务会先被放进宏任务队列中，微任务后被放进微任务队列中。但是微任务有优先执行权，所以微任务会先被放入执行栈中执行！

### eventloop

JS是单线程执行的，那么js如何执行异步任务呢？

浏览器端eventloop

浏览器在执行js时，将环境分为了 `执行栈`，`宏任务队列`，`微任务队列`, `web api`，web api 指其他线程，如计时器线程。

![image](https://wx3.sinaimg.cn/mw690/005QwFx4gy1gg7vee83xhj30ty0if0t1.jpg)

当一个js执行时会按照什么顺序执行呢？

    1. 整个script作为第一个宏任务被执行
    2. script执行中，宏任务进入宏任务队列，微任务进入微任务队列
    3. 如执行到setTimeout这类任务，通知web api的计时线程计时，计时完毕后放入宏任务队列
    4. 如`MutationObserver`这类任务，会告诉浏览器去监听某一个元素，若元素有改变，将回调函数放入微任务队列
    5. 执行栈清空后，检查任务队列
    6. 如果有微任务，将微任务放入执行栈执行，直到微任务执行完毕
    7. 如果有宏任务，将宏任务放入执行栈执行
    8. 进行浏览器UI多线程渲染
    9. 检查web worker任务，有则执行
    10. 循环第2步，直到完成所有任务

注意！
- 微任务队列一定要清空
- 执行栈空了，先看微任务队列，微任务队列空了再看宏任务队列


下面js输出什么？

```js
console.log(111)

setTimeout(() => {
    console.log(222)
}, 0)

Promise.resolve().then(() => console.log(333))
console.log(444)

// 111 444 333 222
```

为什么？

    1. console.log setTimeout都属于宏任务，console.log是同步任务，进入主线程执行
    2. setTimeout进入宏任务队列，promise.then属于微任务，进入微任务队列
    3. 本次宏任务执行完毕，检查微任务队列有一个promise.then，拿出来执行
    4. 下一次宏任务，检查到setTimeout，拿出来执行
